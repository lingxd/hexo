---
title: C++11多线程(1)【初识线程】

date: 2019-11-29 18:21:09

categories: [笔记, C++11, 线程]

tags: [C++11, 线程]
---

## 什么是并发

并发在生活中随处可见，边走路边说话，边听歌边写代码。计算机术语中的"并发"，指的是在单个系统里同时执行多个独立的活动，而不是顺序的一个接一个的执行。对于单核CPU来说，在某个时刻只可能处理一个任务，但它却不是完全执行完一个任务再执行一个下一任务，而是一直在任务间切换，每个任务完成一点就去执行下一个任务，看起来就像任务在并行发生，虽然不是严格的同时执行多个任务，但是我们仍然称之为**并发(concurrency)**。真正的并发是在在多核CPU上，能够真正的同时执行多个任务，称为**硬件并发(hardware concurrency)**。

并发并非没有代价，在单核CPU并发执行两个任务需要付出上下文切换的时间代价。如下图：

![img](https://upload-images.jianshu.io/upload_images/4427263-8e5ee0329a0fe476.png?imageMogr2/auto-orient/strip|imageView2/2/w/1170/format/webp "双核机器的并行执行与单核机器对比")

假设A和B两个任务都被分成10个大小相等的块，单核CPU交替的执行两个任务，每次执行其中一块，其花费的时间并不是先完成A任务再玩成B任务所花费时间的两倍，而是要更多。这是因为系统从一个任务切换到另一个任务需要执行一次**上下文切换**，这是需要时间的(图中的灰色块)。上下文切换需要操作系统为当前运行的任务保存CPU的状态和指令指针，算出要切换到哪个任务，并为要切换的任务重新加载处理器状态。然后将新任务的指令和数据载入到缓存中。

## 并发的方式

### 多进程并发

将应用程序分为多个独立的、单线程的进程，他们可以同时运行。进程内部实现原理比较复杂，这里就不多说了。

![img](https://upload-images.jianshu.io/upload_images/4427263-57705a0a3a475e61.png?imageMogr2/auto-orient/strip|imageView2/2/w/395/format/webp "并发运行的进程之间的通信")

这些独立的进程可以通过常规的[进程间通信机制](https://blog.csdn.net/qq_36132127/article/details/81129690)进行通信，如管道、信号、消息队列、共享内存、存储映射I/O、信号量、套接字等。

缺点：

- 进程间通信较为复杂，速度相对线程间的通信更慢。
- 启动进程的开销比线程大，使用的系统资源也更多。

优点：

- 进程间通信的机制相对于线程更加安全。
- 能够很容易的将一台机器上的多进程程序部署在不同的机器上（如果通信机制选取的是套接字的话）。

### 多线程并发

线程很像轻量级的进程，但是一个进程中的所有线程都共享相同的地址空间，线程间的大部分数据都可以共享。线程间的通信一般都通过共享内存来实现。

![img](https://upload-images.jianshu.io/upload_images/4427263-36814ade375e31bc.png?imageMogr2/auto-orient/strip|imageView2/2/w/298/format/webp "并发运行的线程之间的通信")

优点：

- 由于可以共享数据，多线程间的通信开销比进程小的多。
- 线程启动的比进程快，占用的资源更少。

缺点：

- 共享数据太过于灵活，为了维护正确的共享，代码写起来比较复杂。
- 无法部署在分布式系统上。

## 为什么使用并发

主要原因有两个：任务拆分和提高性能。

### 任务拆分

在编写软件的时候，将相关的代码放在一起，将无关的代码分开，这是一个好主意，这样能够让程序更加容易理解和测试。将程序划分成不同的任务，每个线程执行一个任务或者多个任务，可以将整个程序的逻辑变得更加简单。

### 提高性能

在两种情况下，并发能够提高性能。

1.  **任务并行(task parallelism)**：将一个单个任务分成若干个部分各自并行运行，从而降低运行时间。虽然听起来很简单，但其实是一个相当复杂的过程，设想假如各个部分之间存在很多以来，一个部分的执行需要使用到另一个任务的执行结果，这个时候并不能很好的并行完成。
2.  **数据并行(data parallelism)**：每个线程在不同的数据部分上执行相同的操作。

## 多线程库简介

`C++98`标准中并没有线程库的存在，而在`C++11`中终于提供了多线程的标准库，提供了管理线程、保护共享数据、线程间同步操作、原子操作等类。

多线程库对应的头文件是`#include `，类名为`std::thread`。

一个简单的串行程序如下：

```cpp
#include <iostream>
#include <thread>

void function_1() {
    std::cout << "I'm function_1()" << std::endl;
}

int main() {
    function_1();
    return 0;
}
```

这是一个典型的单线程的单进程程序，任何程序都是一个进程，`main()`函数就是其中的主线程，单个线程都是顺序执行。

将上面的程序改造成多线程程序其实很简单，让`function_1()`函数在另外的线程中执行：

```cpp
#include <iostream>
#include <thread>

void function_1() {
    std::cout << "I'm function_1()" << std::endl;
}

int main() {
    std::thread t1(function_1);
    // do other things
    t1.join();
    return 0;
}
```

分析：

1. 首先，构建一个`std::thread`对象`t1`，构造的时候传递了一个参数，这个参数是一个函数，这个函数就是这个线程的**入口函数**，函数执行完了，整个线程也就执行完了。
2. 线程创建成功后，就会**立即启动**，并没有一个类似`start`的函数来显式的启动线程。
3. 一旦线程开始运行， 就需要显式的决定是要等待它完成(join)，或者分离它让它自行运行(detach)。注意：只需要在`std::thread`对象**被销毁之前**做出这个决定。这个例子中，对象`t1`是栈上变量，在`main`函数执行结束后就会被销毁，所以需要在`main`函数结束之前做决定。
4. 这个例子中选择了使用`t1.join()`，主线程会一直阻塞着，直到子线程完成，`join()`函数的另一个任务是回收该线程中使用的资源。

**线程对象和对象内部管理的线程的生命周期并不一样**，如果线程执行的快，可能内部的线程已经结束了，但是线程对象还活着，也有可能线程对象已经被析构了，内部的线程还在运行。

假设`t1`线程是一个执行的很慢的线程，主线程并不想等待子线程结束就想结束整个任务，直接删掉`t1.join()`是不行的，程序会被终止（析构`t1`的时候会调用`std::terminate`，程序会打印`terminate called without an active exception`）。

与之对应，我们可以调用`t1.detach()`，从而将`t1`线程放在后台运行，所有权和控制权被转交给`C++`运行时库，以确保与线程相关联的资源在线程退出后能被正确的回收。参考`UNIX`的**守护进程(daemon process)**的概念，这种被分离的线程被称为**守护线程(daemon threads)**。线程被分离之后，即使该线程对象被析构了，线程还是能够在后台运行，只是由于对象被析构了，主线程不能够通过对象名与这个线程进行通信。例如：

```cpp
#include <iostream>
#include <thread>

void function_1() {
    //延时500ms 为了保证test()运行结束之后才打印
    std::this_thread::sleep_for(std::chrono::milliseconds(500)); 
    std::cout << "I'm function_1()" << std::endl;
}

void test() {
    std::thread t1(function_1);
    t1.detach();
    // t1.join();
    std::cout << "test() finished" << std::endl;
}

int main() {
    test();
    //让主线程晚于子线程结束
    std::this_thread::sleep_for(std::chrono::milliseconds(1000)); //延时1s
    return 0;
}

// 使用 t1.detach()时
// test() finished
// I'm function_1()

// 使用 t1.join()时
// I'm function_1()
// test() finished
```

分析：

1. 由于线程入口函数内部有个`500ms`的延时，所以在还没有打印的时候，`test()`已经执行完成了，`t1`已经被析构了，但是它负责的那个线程还是能够运行，这就是`detach()`的作用。
2. 如果去掉`main`函数中的`1s`延时，会发现**什么都没有打印**，因为主线程执行的太快，整个程序已经结束了，那个后台线程被`C++`运行时库回收了。
3. 如果将`t1.detach()`换成`t1.join()`，`test`函数会在`t1`线程执行结束之后，才会执行结束。

一旦一个线程被分离了，就不能够再被`join`了。如果非要调用，程序就会崩溃，可以使用`joinable()`函数判断一个线程对象能否调用`join()`。

```cpp
void test() {
    std::thread t1(function_1);
    t1.detach();

    if(t1.joinable())
        t1.join();

    assert(!t1.joinable());
}
```

作者：[StormZhu](https://www.jianshu.com/u/a549acfa2f33)